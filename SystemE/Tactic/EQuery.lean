import Smt.Data.Graph
import Smt.Translate.Commands
import Smt.Translate
import Smt.Tactic.EqnDef
import Smt.Util
import Smt.Translate.Query

namespace Smt.Translate.Query

open Lean Expr Meta
open Term

#check generateQuery


def addCommandForConstant (oldGoalExprs : List Expr) (cName : Name) (initialState : QueryBuilderM.State) : MetaM (QueryBuilderM.State × List Expr × List Command) := do
  let constInfo ← getConstInfo cName
  let constExpr := mkConst cName (constInfo.levelParams.map Level.param)
  let ((_, st), _) ← do
    QueryBuilderM.buildDependencyGraph constExpr
    |>.run { toDefine := [] : QueryBuilderM.Config }
    |>.run initialState
    |>.run { uniqueFVarNames := {} : TranslationM.State }
  let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldGoalExprs ++ [constExpr]) (emitVertex st.commands)) []
  return ⟨st, oldGoalExprs ++ [constExpr], cmds⟩


-- def addCommandForExpr (oldGoalExprs : List Expr) (e : Expr) (initialState : QueryBuilderM.State) : MetaM (QueryBuilderM.State × List Expr × List Command) :=
--   withTraceNode `smt.translate.query (fun _ => pure .nil) do
--     let goalId ← Lean.mkFreshMVarId
--     Lean.Meta.withLocalDeclD goalId.name e fun g => do
--       let ((_, st), _) ← do
--         QueryBuilderM.buildDependencyGraph g
--         |>.run { toDefine := [] : QueryBuilderM.Config }
--         |>.run initialState
--         |>.run { uniqueFVarNames := {} : TranslationM.State }
--       -- trace[smt.translate.query] "Dependency Graph: {st.graph}"
--       -- The type of the proof generated by a solver depends on the order of asserions. We assert the
--       -- Lean goal at the end of the query to simplify unification during proof reconstruction.
--       let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldGoalExprs ++ [g]) (emitVertex st.commands)) []
--       return ⟨st, oldGoalExprs ++ [g], cmds⟩

def generateQuery' (oldExprs : List Expr) (initialState : QueryBuilderM.State := { : QueryBuilderM.State }) (goal : Expr) (hs : List Expr) (fvNames : Std.HashMap FVarId String) : MetaM (List Command) :=
  withTraceNode `smt.translate.query (fun _ => pure .nil) do
    trace[smt.translate.query] "Goal: {← Lean.Meta.inferType goal}"
    trace[smt.translate.query] "Provided Hints: {hs}"
    let dfns ← hs.filterM fun h => do
      -- We need to define `const`s that are not theorems and `fvar`s from `let`s that are not assumptions.
      if h.isFVar then
        let fv := h.fvarId!
        let decl ← fv.getDecl
        (pure decl.isLet) <&&> notM (Meta.inferType decl.type >>= pure ∘ Expr.isProp)
      else if h.isConst then
        let info ← getConstInfo h.constName
        return !info.isTheorem
      else
        return false
    trace[smt.translate.query] "Definitions: {dfns}"
    let ((_, st), _) ← QueryBuilderM.buildDependencyGraph goal
      |>.run { toProcess := hs, toDefine := dfns : QueryBuilderM.Config }
      |>.run initialState
      |>.run { uniqueFVarNames := fvNames : TranslationM.State }
    trace[smt.translate.query] "Dependency Graph: {st.graph}"
    -- The type of the proof generated by a solver depends on the order of asserions. We assert the
    -- Lean goal at the end of the query to simplify unification during proof reconstruction.
    let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldExprs ++ hs ++ [goal]) (emitVertex st.commands)) []
    return cmds.reverse
