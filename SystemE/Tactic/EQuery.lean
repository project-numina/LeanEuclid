import Smt.Data.Graph
import Smt.Translate.Commands
import Smt.Translate
import Smt.Tactic.EqnDef
import Smt.Util
import Smt.Translate.Query

namespace Smt.Translate.Query

open Lean Expr Meta
open Term

#check generateQuery

def generateQuery' (goal : Expr) (hs : List Expr) (fvNames : Std.HashMap FVarId String) (initialState : QueryBuilderM.State) : MetaM (QueryBuilderM.State × List Command) :=
  withTraceNode `smt.translate.query (fun _ => pure .nil) do
    trace[smt.translate.query] "Goal: {← inferType goal}"
    trace[smt.translate.query] "Provided Hints: {hs}"
    let ((_, st), _) ← do
      QueryBuilderM.buildDependencyGraph goal
      |>.run { toDefine := hs : QueryBuilderM.Config }
      |>.run initialState
      |>.run { uniqueFVarNames := fvNames : TranslationM.State }
    trace[smt.translate.query] "Dependency Graph: {st.graph}"
    -- The type of the proof generated by a solver depends on the order of asserions. We assert the
    -- Lean goal at the end of the query to simplify unification during proof reconstruction.
    let (_, cmds) ← StateT.run (st.graph.orderedDfs (hs ++ [goal]) (emitVertex st.commands)) []
    return (st, cmds.reverse)
